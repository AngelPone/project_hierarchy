---
title: "Constructing hierarchies"
author: "Bohan Zhang"
date: "2023-09-26"
output:
  html_document:
    df_print: paged
  pdf_document: default
---


# Illustrative example

Consider a hierarchy with $4$ time series A,C,D,E, $A=C+D+E$. We consider
two kind of aggregation $B_1 = D+E$, $B_2 = C+D$.

```{r, include=FALSE, echo=FALSE}

set.seed(1065)
S <- rbind(c(1,1,1), c(0, 1, 1), diag(3))


weights <- function(W) {
  W_inv <- solve(W)
  S %*% solve(t(S) %*% W_inv %*% S, t(S) %*% W_inv)
}


weights_plot <- function(offdiag, title = "Setting 1") {
  
  
  construct_W <- function(offdiag, x) {
    m <- matrix(0, 5, 5)
    m[lower.tri(m)] <- offdiag
    m[upper.tri(m)] <- t(m)[upper.tri(t(m))]
    diag(m) <- c(1, 1, 1, 1, 1)
    m[4, 5] <- x
    m[5, 4] <- x
    diag(sqrt(c(3, 2.1, 0.9, 1.05, 1.04))) %*% m %*% diag(sqrt(c(3, 2.1, 0.9, 1.05, 1.04)))
  }
  print(construct_W(offdiag, 0.5))
  
  weights_all <- vector("list", 5)
  
  for (i in seq(-0.99, 0.99, by = 0.01)) {
    W <- construct_W(offdiag, i)
    weight_i <- weights(W)
    for (j in 1:5){
      weights_all[[j]] <- rbind(weights_all[[j]], c(i, weight_i[,j]))
    }
  }
  library(dplyr)
  for (j in 1:5) {
    colnames(weights_all[[j]]) <- c("cor", "A", "B", "C", "D", "E")
    weights_all[[j]] <- as_tibble(weights_all[[j]]) %>%
      mutate(weights_col = c("A", "B", "C", "D", "E")[j])
  }
  
  weights_all <- do.call(rbind, weights_all)
  
  weights_all <- weights_all %>% tidyr::pivot_longer(names_to = "weights_row", cols = c("A", "B", "C", "D", "E"))
  
  library(ggplot2)
  
  ggplot(weights_all)  +
    geom_line(mapping = aes(x = cor, y = value, color = weights_row, group=weights_row)) +
    facet_wrap(~ weights_col) +
    ggtitle(title)
}
```


## Trend of weights

Consider the hierarchy $A, B_1, C, D, E$, $B_1 = D+E$ and variance $[3, 2.1, 0.9, 1.05, 1.04]'$

### Trend of weights: Scenario 1

All the correlation coefficients are $0$.

$$
\begin{bmatrix}
1 & 0 & 0 & 0 & 0 \\
0 &1 & 0 & 0 & 0 \\
0 & 0 & 1 & 0 & 0 \\
0 & 0 & 0 & 1 & x \\
0 & 0 & 0 & x & 1
\end{bmatrix}
$$

The trends of weights:

```{r, echo=FALSE, message=FALSE, results='hide'}
weights_plot(0)
```

### Trend of weights: Scenario 2

All the correlation coefficients are uniformly drawn from $[0, 0.5]$.

```{r, echo=FALSE, message=FALSE}
offdiag <- runif(10, 0, 0.5)
weights_plot(offdiag, title = "Setting 2")
```



### Trend of weights: Scenario 3

All the correlation coefficients are uniformly drawn from $[-0.5, 0]$.

```{r, echo=FALSE, message=FALSE}
offdiag <- runif(10, -0.5, 0)
weights_plot(offdiag, title = "Setting 3")
```

### Trend of weights: Scenario 4

All the correlation coefficients are uniformly drawn from $[-0.5, 0.5]$.

```{r, echo=FALSE, message=FALSE}
offdiag <- runif(10, -0.5, 0.5)
weights_plot(offdiag, title = "Setting 4")
```




### Conclusion

Overall, the weights for Series $B_1, D, E, A$ from Series $B_1$ ($G_{B_1,B_1}, G_{D,B_1}, G_{E,B_1}, G_{A, B_1}$) increase as the correlation between $D$ and $E$ increase. (See the panel B in each figure)



## forecast accuracy of two different grouping method: B1 and B2

```{r, echo=FALSE, message=FALSE}
source("illurstrative.R")
```


Simulation procedure:

1. produce time series
2. test reconciliation accuracy for $B_1$ hierarchy and $B_2$ hierarchy through CV.

$$
\begin{bmatrix}
e_{C,t} \\ e_{D,t} \\ e_{E,t}
\end{bmatrix} = \begin{bmatrix}
0 & 0 & 0 \\
0 & 0.4 & x \\
0 & x & 0.4
\end{bmatrix} \begin{bmatrix}
e_{C,t-1} \\ e_{D,t-1} \\ e_{E,t-1}
\end{bmatrix} + \begin{bmatrix}
\varepsilon_{C,t} \\ \varepsilon_{D,t} \\ \varepsilon_{E,t}
\end{bmatrix}
$$
$$
\begin{bmatrix}
y_{C,t} \\ y_{D,t} \\ y_{E,t}
\end{bmatrix} = \begin{bmatrix}
0 \\
0.05 \\
0.045
\end{bmatrix} t + \begin{bmatrix}
e_{C,t} \\ e_{D,t} \\ e_{E,t}
\end{bmatrix}
$$



$\boldsymbol{\varepsilon}_t$ are white noises.

```{r}
r1 <- step2(c(0.3, 0.3))
r1 %>% mutate(mint = mint/base, mint2 = mint2/base) %>% group_by(names) %>% summarise_at(c("mint", "mint2"), mean)


r2 <- step2(c(0, 0))
r2 %>% mutate(mint = mint/base, mint2 = mint2/base) %>% group_by(names) %>% summarise_at(c("mint", "mint2"), mean)

r3 <- step2(c(-0.3, -0.4))
#r3 %>% group_by(names) %>% summarise_at(c("base", "mint", "mint2"), mean)
r3 %>% mutate(mint = mint/base, mint2 = mint2/base) %>% group_by(names) %>% summarise_at(c("mint", "mint2"), mean)

```



## Mortality


```{r, echo=FALSE, message=FALSE}

library(dplyr)
library(tidyr)

# ts and error representator
source("R/construct_hierarchy.R", chdir = TRUE)

rf_method <- "mint"
accuracy_method <- "rmse"

# read all the results
store_all <- NULL
for (batch in 0:11) {
  store_all <- readRDS(paste0("mortality/store_", batch, ".rds"))$output %>%
    output_pre() %>% mutate(batch = batch) %>%
    filter(rf_method == .env$rf_method, accuracy_method == .env$accuracy_method) %>%
    dplyr::select(-rf_method, -accuracy_method) %>%
    rbind(store_all)
}

store_all <- store_all %>% rowwise() %>%
  mutate(values = list(c(total, bottom))) %>% ungroup() %>%
  dplyr::select(-total, -bottom)

## remove single random
store_all <- store_all %>% filter(!startsWith(cluster, "random-single"))

# store_all %>% group_by(representator, distance, cluster) %>% tally() %>%
#   pull(n) %>% table()

## combine the results of 12 batches for one clustering method

store_all <- store_all %>% select(-other) %>% nest(values = c(batch, values)) %>%
  mutate_at("values", purrr::map, function(x){
    x <- arrange(x, batch)
    do.call(c, x$values)
  })

## convert the tibble to a data.frame used for comparing ranks
store_mat <- do.call(cbind, store_all$values)
store_rank <- apply(store_mat, 1, rank) %>% t() %>% colMeans()
store_all$rank <- store_rank

## MCB test
mcb <- function(x) {
  tsutils::nemenyi(x, plottype = "vmcb")
}

method_desc <- function(row){
  print(sprintf("representator: %s, distance: %s, cluster: %s",
                store_all$representator[row],
                store_all$distance[row],
                store_all$cluster[row]))
}
```

### Overall rank


```{r}
mcb(store_mat)
```

```{r}
store_all %>% arrange(rank)
```


### representator rank

```{r, include=FALSE}

which.best <- function(x){
  names(x$means)[1]
}

is.bestsignificant <- function(x){
  x$mean[1] + x$cd/2 < x$mean[2] - x$cd/2
}

which.worst <- function(x){
  names(x$means)[length(x$means)]
}

is.worstsignificant <- function(x){
  x$mean[1] + x$cd/2 < x$mean[x$k] - x$cd/2
}

tmp_mcb <- function(x){
  a <- do.call(cbind, x$values)
  colnames(a) <- x$representator
  tsutils::nemenyi(a, plottype = "vmcb")
}
```

```{r}
# representator rank
representator_summarise <- store_all %>% filter(distance != "") %>%
  nest(values = c(representator, values, rank)) %>%
  mutate(orig_values = values) %>%
  mutate_at("values", purrr::map, function(x){

    a <- do.call(cbind, x$values)
    colnames(a) <- x$representator
    tsutils::nemenyi(a, plottype = "none")
  })

representator_summarise <- representator_summarise %>%
  rowwise() %>% mutate(best = which.best(values),
                       sigbest = is.bestsignificant(values),
                       worst = which.worst(values),
                       sigworst = is.worstsignificant(values))

representors <- c("ts", "error", "ts.features", "error.features", "forecast")
for (method in representors) {
  print(sprintf("In %s cases, %s is the best, where %s is significantly best. In %s cases, it is the worst, where %s is significantly worse than the best one.",
                NROW(representator_summarise %>% filter(best == method)),
                method,
                NROW(representator_summarise %>% filter(best == method, sigbest)),
                NROW(representator_summarise %>% filter(worst == method)),
                NROW(representator_summarise %>% filter(worst == method, sigworst))))
}
```

```{r}

# no hierarchy is not good: 391 / 428
rank(store_all$rank)[1]

# natural hierarchy is not bad: 72/428
rank(store_all$rank)[2]

# random versus random natural versus natural

tmp <- store_all %>% filter(distance == "")
tmp$rank <- do.call(cbind, tmp$values) %>% apply(1, rank) %>%
  t() %>% colMeans()
```


### cluster rank
```{r}
# cluster rank
cluster_summarise <- store_all %>% filter(distance != "") %>%
  nest(values = c(cluster, values, rank)) %>%
  mutate(orig_values = values) %>%
  mutate_at("values", purrr::map, function(x){
    a <- do.call(cbind, x$values)
    colnames(a) <- x$cluster
    tsutils::nemenyi(a, plottype = "none")
  }) %>% rowwise() %>% mutate(best = which.best(values),
                       sigbest = is.bestsignificant(values),
                       worst = which.worst(values),
                       sigworst = is.worstsignificant(values))

cluster_summarise
```


### distance rank

```{r}

distance_summarise <- store_all %>% filter(distance != "") %>%
  nest(values = c(distance, values, rank)) %>%
  mutate(orig_values = values) %>%
  mutate_at("values", purrr::map, function(x){
    a <- do.call(cbind, x$values)
    colnames(a) <- x$distance
    tsutils::nemenyi(a, plottype = "none")
  }) %>% rowwise() %>% mutate(best = which.best(values),
                       sigbest = is.bestsignificant(values),
                       worst = which.worst(values),
                       sigworst = is.worstsignificant(values))

distance_summarise
```

```{r}
distances <- c("cor", "dtw", "euclidean", "negcor", "uncorrelation")
for (method in distances) {
  print(sprintf("In %s cases, %s is the best, where %s is significantly best. In %s cases, it is the worst, where %s is significantly worse than the best one.",
                NROW(distance_summarise %>% filter(best == method)),
                method,
                NROW(distance_summarise %>% filter(best == method, sigbest)),
                NROW(distance_summarise %>% filter(worst == method)),
                NROW(distance_summarise %>% filter(worst == method, sigworst))))
}
```



## Tourism

```{r, include=FALSE, echo=FALSE}
store_all <- NULL
for (batch in 0:11) {
  store_all <- readRDS(paste0("tourism/store_", batch, ".rds"))$output %>%
    output_pre() %>% mutate(batch = batch) %>%
    filter(rf_method == .env$rf_method, accuracy_method == .env$accuracy_method) %>%
    dplyr::select(-rf_method, -accuracy_method) %>%
    rbind(store_all)
}

store_all <- store_all %>% rowwise() %>%
  mutate(values = list(c(total, bottom))) %>% ungroup() %>%
  dplyr::select(-total, -bottom)

## remove single random
store_all <- store_all %>% filter(!startsWith(cluster, "random-single"))

## combine the results of 12 batches for one clustering method

store_all <- store_all %>% dplyr::select(-other) %>% nest(values = c(batch, values)) %>%
  mutate_at("values", purrr::map, function(x){
    x <- arrange(x, batch)
    do.call(c, x$values)
  })

## convert the tibble to a data.frame used for comparing ranks
store_mat <- do.call(cbind, store_all$values)
store_rank <- apply(store_mat, 1, rank) %>% t() %>% colMeans()
store_all$rank <- store_rank
```


```{r}
mcb(store_mat)
```
```{r}
store_all %>% arrange(rank)
```

### representor rank

```{r}
# representator rank
representor_summarise <- store_all %>% filter(distance != "") %>%
  nest(values = c(representator, values, rank)) %>%
  mutate(orig_values = values) %>%
  mutate_at("values", purrr::map, function(x){

    a <- do.call(cbind, x$values)
    colnames(a) <- x$representator
    tsutils::nemenyi(a, plottype = "none")
  })

representor_summarise <- representor_summarise %>%
  rowwise() %>% mutate(best = which.best(values),
                       sigbest = is.bestsignificant(values),
                       worst = which.worst(values),
                       sigworst = is.worstsignificant(values))

representors <- c("ts", "error", "ts.features", "error.features", "forecast")
for (method in representors) {
  print(sprintf("In %s cases, %s is the best, where %s is significantly best. In %s cases, it is the worst, where %s is significantly worse than the best one.",
                NROW(representor_summarise %>% filter(best == method)),
                method,
                NROW(representor_summarise %>% filter(best == method, sigbest)),
                NROW(representor_summarise %>% filter(worst == method)),
                NROW(representor_summarise %>% filter(worst == method, sigworst))))
}
```

```{r}
print(sprintf("rank of no clustering: %s/512", rank(store_all$rank)[which(store_all$cluster == "")]))
print(sprintf("rank of natural hierarchy: %s/512", rank(store_all$rank)[which(store_all$cluster == "natural")]))

# random versus random natural versus natural

tmp <- store_all %>% filter(distance == "")
tmp$rank <- do.call(cbind, tmp$values) %>% apply(1, rank) %>%
  t() %>% colMeans()
tmp %>% arrange(rank)
```


### cluster rank
```{r}
# cluster rank
cluster_summarise <- store_all %>% filter(distance != "") %>%
  nest(values = c(cluster, values, rank)) %>%
  mutate(orig_values = values) %>%
  mutate_at("values", purrr::map, function(x){
    a <- do.call(cbind, x$values)
    colnames(a) <- x$cluster
    tsutils::nemenyi(a, plottype = "none")
  }) %>% rowwise() %>% mutate(best = which.best(values),
                       sigbest = is.bestsignificant(values),
                       worst = which.worst(values),
                       sigworst = is.worstsignificant(values))

cluster_summarise
```


### distance rank

```{r}

distance_summarise <- store_all %>% filter(distance != "") %>%
  nest(values = c(distance, values, rank)) %>%
  mutate(orig_values = values) %>%
  mutate_at("values", purrr::map, function(x){
    a <- do.call(cbind, x$values)
    colnames(a) <- x$distance
    tsutils::nemenyi(a, plottype = "none")
  }) %>% rowwise() %>% mutate(best = which.best(values),
                       sigbest = is.bestsignificant(values),
                       worst = which.worst(values),
                       sigworst = is.worstsignificant(values))

distance_summarise
```

```{r}
distances <- c("cor", "dtw", "euclidean", "negcor", "uncorrelation")
for (method in distances) {
  print(sprintf("In %s cases, %s is the best, where %s is significantly best. In %s cases, it is the worst, where %s is significantly worse than the best one.",
                NROW(distance_summarise %>% filter(best == method)),
                method,
                NROW(distance_summarise %>% filter(best == method, sigbest)),
                NROW(distance_summarise %>% filter(worst == method)),
                NROW(distance_summarise %>% filter(worst == method, sigworst))))
}
```

## Prison


```{r, include=FALSE, echo=FALSE}
store_all <- NULL
for (batch in 0:7) {
  store_all <- readRDS(paste0("prison/store_", batch, ".rds"))$output %>%
    output_pre() %>% mutate(batch = batch) %>%
    filter(rf_method == .env$rf_method, accuracy_method == .env$accuracy_method) %>%
    dplyr::select(-rf_method, -accuracy_method) %>%
    rbind(store_all)
}

store_all <- store_all %>% rowwise() %>%
  mutate(values = list(c(total, bottom))) %>% ungroup() %>%
  dplyr::select(-total, -bottom)

## remove single random
store_all <- store_all %>% filter(!startsWith(cluster, "random-single"))

# store_all %>% group_by(representator, distance, cluster) %>% tally() %>%
#   pull(n) %>% table()

## combine the results of 12 batches for one clustering method

store_all <- store_all %>% dplyr::select(-other) %>% nest(values = c(batch, values)) %>%
  mutate_at("values", purrr::map, function(x){
    x <- arrange(x, batch)
    do.call(c, x$values)
  })

## convert the tibble to a data.frame used for comparing ranks
store_mat <- do.call(cbind, store_all$values)
store_rank <- apply(store_mat, 1, rank) %>% t() %>% colMeans()
store_all$rank <- store_rank
```


```{r}
mcb(store_mat)
```
For prison data, all the methods are insignificantly different.
```{r}
store_all %>% arrange(rank)
```

### representator rank

```{r}
# representator rank
representator_summarise <- store_all %>% filter(distance != "") %>%
  nest(values = c(representator, values, rank)) %>%
  mutate(orig_values = values) %>%
  mutate_at("values", purrr::map, function(x){

    a <- do.call(cbind, x$values)
    colnames(a) <- x$representator
    tsutils::nemenyi(a, plottype = "none")
  })

representator_summarise <- representator_summarise %>%
  rowwise() %>% mutate(best = which.best(values),
                       sigbest = is.bestsignificant(values),
                       worst = which.worst(values),
                       sigworst = is.worstsignificant(values))

representors <- c("ts", "error", "ts.features", "error.features", "forecast")
for (method in representors) {
  print(sprintf("In %s cases, %s is the best, where %s is significantly best. In %s cases, it is the worst, where %s is significantly worse than the best one.",
                NROW(representator_summarise %>% filter(best == method)),
                method,
                NROW(representator_summarise %>% filter(best == method, sigbest)),
                NROW(representator_summarise %>% filter(worst == method)),
                NROW(representator_summarise %>% filter(worst == method, sigworst))))
}
```

```{r}
# no hierarchy is not good: 391 / 428
print(sprintf("rank of no clustering: %s", rank(store_all$rank)[1]))

# natural hierarchy is not bad: 72/428
print(sprintf("rank of natural hierarchy: %s", rank(store_all$rank)[2]))

# random versus random natural versus natural

tmp <- store_all %>% filter(distance == "")
tmp$rank <- do.call(cbind, tmp$values) %>% apply(1, rank) %>%
  t() %>% colMeans()
```


### cluster rank
```{r}
# cluster rank
cluster_summarise <- store_all %>% filter(distance != "") %>%
  nest(values = c(cluster, values, rank)) %>%
  mutate(orig_values = values) %>%
  mutate_at("values", purrr::map, function(x){
    a <- do.call(cbind, x$values)
    colnames(a) <- x$cluster
    tsutils::nemenyi(a, plottype = "none")
  }) %>% rowwise() %>% mutate(best = which.best(values),
                       sigbest = is.bestsignificant(values),
                       worst = which.worst(values),
                       sigworst = is.worstsignificant(values))

cluster_summarise
```


### distance rank

```{r}

distance_summarise <- store_all %>% filter(distance != "") %>%
  nest(values = c(distance, values, rank)) %>%
  mutate(orig_values = values) %>%
  mutate_at("values", purrr::map, function(x){
    a <- do.call(cbind, x$values)
    colnames(a) <- x$distance
    tsutils::nemenyi(a, plottype = "none")
  }) %>% rowwise() %>% mutate(best = which.best(values),
                       sigbest = is.bestsignificant(values),
                       worst = which.worst(values),
                       sigworst = is.worstsignificant(values))

distance_summarise
```

```{r}
distances <- c("cor", "dtw", "euclidean", "negcor", "uncorrelation")
for (method in distances) {
  print(sprintf("In %s cases, %s is the best, where %s is significantly best. In %s cases, it is the worst, where %s is significantly worse than the best one.",
                NROW(distance_summarise %>% filter(best == method)),
                method,
                NROW(distance_summarise %>% filter(best == method, sigbest)),
                NROW(distance_summarise %>% filter(worst == method)),
                NROW(distance_summarise %>% filter(worst == method, sigworst))))
}
```



